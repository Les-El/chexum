# Checkpoint Update: Hash String Detection & Comparison
**Date**: 2026-01-16 15:53  
**Status**: Planning Phase  
**Implementation Strategy**: Option C (Hybrid Detection)

## Context

Review of `scratchpad3.txt` revealed three concepts from the original hashi design:
1. âœ… **Passing hash strings as arguments** - Infrastructure exists but not wired up
2. âŒ **TRUE/FALSE output for file+hash comparison** - Not implemented
3. âŒ **Boolean-only output flag for scripting** - Not implemented

### Design Decision: Option C (Hybrid Detection)

**Principle**: Be explicit and helpful, don't surprise users.

**Rules**:
1. If hash length matches current algorithm â†’ use it silently
2. If hash length matches different algorithm â†’ error with helpful suggestion
3. For validation-only (`hashi [string]`) â†’ detect and report all possibilities
4. Filesystem check happens BEFORE hash detection (files take precedence)

**Hash Length Reference**:
- CRC32: 8 characters
- MD5: 32 characters
- SHA-1: 40 characters
- SHA-256: 64 characters (default)
- SHA-512: 128 characters
- BLAKE2b-512: 128 characters

---

## Tasks

### PHASE 1: Core Detection Logic

#### Task 1.1: Add Hash Algorithm Detection Function
**File**: `internal/hash/hash.go`

**Add function**:
```go
// DetectHashAlgorithm returns possible algorithms for a hash string.
// Returns empty slice if not a valid hash format.
// Returns multiple algorithms if ambiguous (e.g., SHA-512 and BLAKE2b-512 both = 128 chars).
//
// Parameters:
//   hashStr - the string to analyze
//
// Returns:
//   []string - list of possible algorithms, empty if invalid format
func DetectHashAlgorithm(hashStr string) []string
```

**Logic**:
1. Check if string contains only hex characters (0-9, a-f, A-F)
2. Check length against known algorithms
3. Return all matching algorithms
4. Return empty slice if no match

**Example outputs**:
- `"a1b2c3d4..."` (32 chars) â†’ `["md5"]`
- `"abc123..."` (64 chars) â†’ `["sha256"]`
- `"def456..."` (128 chars) â†’ `["sha512", "blake2b"]`
- `"xyz"` (3 chars) â†’ `[]`
- `"gggggg..."` (64 chars, invalid hex) â†’ `[]`

#### Task 1.2: Add Argument Classification Function
**File**: `internal/config/config.go` (or new `internal/args/args.go`)

**Add function**:
```go
// ClassifyArguments separates command-line arguments into files and hash strings.
// It uses filesystem checks and hash format detection to determine the type.
//
// Parameters:
//   args - raw command-line arguments (after flag parsing)
//   algorithm - the current hash algorithm (from --algo flag or default)
//
// Returns:
//   files - list of file paths
//   hashes - list of hash strings
//   error - helpful error if hash doesn't match current algorithm
func ClassifyArguments(args []string, algorithm string) (files []string, hashes []string, err error)
```

**Logic for each argument**:
1. Check if file exists with `os.Stat(arg)` â†’ add to files list
2. If not a file, call `hash.DetectHashAlgorithm(arg)`
3. If no algorithms detected â†’ treat as file (will error later if not found)
4. If algorithms detected:
   - If current algorithm in list â†’ add to hashes list
   - If current algorithm NOT in list and only 1 detected â†’ return error with suggestion
   - If current algorithm NOT in list and multiple detected â†’ return error listing options

**Error messages**:
```
Hash length doesn't match sha256 (expected 64 characters, got 32).
This looks like MD5. Try: hashi --algo md5 file.txt [hash]
```

```
Hash length doesn't match sha256 (expected 64 characters, got 128).
Could be: sha512, blake2b
Specify algorithm with: hashi --algo sha512 file.txt [hash]
```

#### Task 1.3: Integrate Classification into ParseArgs
**File**: `internal/config/config.go`

**Current code** (around line 640):
```go
// Collect remaining arguments as files
cfg.Files = fs.Args()
```

**Replace with**:
```go
// Classify arguments into files and hashes
var err error
cfg.Files, cfg.Hashes, err = ClassifyArguments(fs.Args(), cfg.Algorithm)
if err != nil {
    return nil, err
}
```

**Note**: This happens AFTER flag parsing, so `cfg.Algorithm` is already set.

---

### PHASE 2: Configuration & Auto-Loading

#### Task 2.1: Add Config File Auto-Discovery
**File**: `internal/config/config.go`

**Add function**:
```go
// FindConfigFile searches for config files in standard locations.
// Returns the first file found, or empty string if none exist.
// Search order: ./.hashi.json > ~/.config/hashi/config.json > ~/.hashi/config.json
//
// This allows users to set default algorithm and other preferences without
// specifying --config every time.
func FindConfigFile() string
```

**Implementation**:
```go
func FindConfigFile() string {
    locations := []string{
        "./.hashi.json",  // Project-specific (highest priority)
        filepath.Join(os.Getenv("XDG_CONFIG_HOME"), "hashi", "config.json"), // XDG standard
        filepath.Join(os.Getenv("HOME"), ".config", "hashi", "config.json"), // XDG fallback
        filepath.Join(os.Getenv("HOME"), ".hashi", "config.json"),           // Traditional dotfile
    }
    
    for _, loc := range locations {
        if loc == "" {
            continue
        }
        if _, err := os.Stat(loc); err == nil {
            return loc
        }
    }
    return ""
}
```

**Note**: Handle empty `XDG_CONFIG_HOME` and `HOME` gracefully.

#### Task 2.2: Integrate Auto-Loading into ParseArgs
**File**: `internal/config/config.go` - `ParseArgs()` function

**Current flow** (around line 640):
```go
// Parse the arguments
if err := fs.Parse(args); err != nil {
    return nil, err
}

// Handle format shorthands
if jsonOutput {
    cfg.OutputFormat = "json"
}
// ... more flag processing ...

// Validate the configuration
if err := ValidateConfig(cfg); err != nil {
    return nil, err
}
```

**New flow** (insert after flag parsing, before validation):
```go
// Parse the arguments
if err := fs.Parse(args); err != nil {
    return nil, err
}

// Handle format shorthands
if jsonOutput {
    cfg.OutputFormat = "json"
}
// ... existing flag processing ...

// Auto-load config file if --config not specified
if cfg.ConfigFile == "" {
    cfg.ConfigFile = FindConfigFile()
}

// Load config file if found
if cfg.ConfigFile != "" {
    configData, err := LoadConfigFile(cfg.ConfigFile)
    if err != nil {
        return nil, fmt.Errorf("failed to load config file: %w", err)
    }
    if err := configData.ApplyConfigFile(cfg); err != nil {
        return nil, fmt.Errorf("failed to apply config: %w", err)
    }
}

// Load and apply environment variables (after config file, before validation)
env := LoadEnvConfig()
env.ApplyEnvConfig(cfg)

// Validate the configuration
if err := ValidateConfig(cfg); err != nil {
    return nil, err
}
```

**Precedence order** (highest to lowest):
1. Command-line flags
2. Environment variables (`HASHI_*`)
3. Config file (auto-discovered or specified)
4. Built-in defaults

#### Task 2.3: Update Help Text - Configuration Section
**File**: `internal/config/config.go` - `HelpText()` function

**Replace current CONFIGURATION section** (around line 710):
```go
CONFIGURATION
  -c, --config string       Path to config file
```

**With expanded section**:
```go
CONFIGURATION
  -c, --config string       Path to config file (overrides auto-discovery)

  Config files are auto-loaded from (in order):
    1. ./.hashi.json                    (project-specific)
    2. ~/.config/hashi/config.json      (XDG standard)
    3. ~/.hashi/config.json             (traditional dotfile)

  Config file format (JSON):
    {
      "algorithm": "sha512",
      "recursive": true,
      "output_format": "json",
      "exclude": ["*.tmp", "*.log"]
    }

  Setting precedence (highest to lowest):
    1. Command-line flags (--algo, --recursive, etc.)
    2. Environment variables (HASHI_ALGORITHM, etc.)
    3. Config file (auto-loaded or --config specified)
    4. Built-in defaults (sha256, non-recursive, etc.)
```

#### Task 2.4: Update Help Text - Environment Variables Section
**File**: `internal/config/config.go` - `HelpText()` function

**Replace current ENVIRONMENT VARIABLES section** (around line 730):
```go
ENVIRONMENT VARIABLES
  NO_COLOR      Disable color output
  DEBUG         Enable debug logging
  HASHI_CONFIG  Default config file path
```

**With comprehensive list**:
```go
ENVIRONMENT VARIABLES
  HASHI_ALGORITHM       Default hash algorithm (sha256, md5, sha1, sha512, blake2b)
  HASHI_OUTPUT_FORMAT   Default output format (default, verbose, json, plain)
  HASHI_RECURSIVE       Enable recursive mode (true/false/1/0)
  HASHI_HIDDEN          Include hidden files (true/false/1/0)
  HASHI_VERBOSE         Enable verbose output (true/false/1/0)
  HASHI_QUIET           Suppress stdout (true/false/1/0)
  HASHI_PRESERVE_ORDER  Keep input order (true/false/1/0)
  HASHI_CONFIG          Override config file location
  NO_COLOR              Disable color output (any value)
  DEBUG                 Enable debug logging (any value)

  Example:
    export HASHI_ALGORITHM=sha512
    export HASHI_RECURSIVE=true
    hashi  # Uses SHA-512 and recursive mode by default
```

---

### PHASE 3: New Features

#### Task 3.1: Test Config File Auto-Discovery
**File**: `internal/config/config_test.go`

**Add test**:
```go
func TestFindConfigFile(t *testing.T) {
    // Save original env vars
    origHome := os.Getenv("HOME")
    origXDG := os.Getenv("XDG_CONFIG_HOME")
    defer func() {
        os.Setenv("HOME", origHome)
        os.Setenv("XDG_CONFIG_HOME", origXDG)
    }()
    
    // Create temp directory structure
    tmpDir := t.TempDir()
    os.Setenv("HOME", tmpDir)
    os.Setenv("XDG_CONFIG_HOME", filepath.Join(tmpDir, ".config"))
    
    tests := []struct {
        name           string
        createFiles    []string
        expectedFound  string
        changeDir      string
    }{
        {
            name:          "Project-specific takes precedence",
            createFiles:   []string{".hashi.json", ".config/hashi/config.json"},
            expectedFound: ".hashi.json",
        },
        {
            name:          "XDG config found",
            createFiles:   []string{".config/hashi/config.json"},
            expectedFound: filepath.Join(tmpDir, ".config/hashi/config.json"),
        },
        {
            name:          "Traditional dotfile found",
            createFiles:   []string{".hashi/config.json"},
            expectedFound: filepath.Join(tmpDir, ".hashi/config.json"),
        },
        {
            name:          "No config files",
            createFiles:   []string{},
            expectedFound: "",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Create test files...
            // Call FindConfigFile()...
            // Assert result...
        })
    }
}
```

#### Task 3.2: Test Config Precedence
**File**: `internal/config/config_test.go`

**Add integration test**:
```go
func TestConfigPrecedence(t *testing.T) {
    // Test that flags > env vars > config file > defaults
    // Create config file with algorithm=md5
    // Set HASHI_ALGORITHM=sha1
    // Pass --algo sha512
    // Verify final config uses sha512
}
```

---

### PHASE 4: New Features

#### Task 4.1: Hash String Validation Mode
**File**: `cmd/hashi/main.go`

**Add logic** (after config parsing, before main processing):
```go
// Mode 1: Hash string validation only
// User ran: hashi [hash_string]
if len(cfg.Files) == 0 && len(cfg.Hashes) > 0 {
    exitCode := validateHashStrings(cfg, colorHandler)
    os.Exit(exitCode)
}
```

**New function to implement**:
```go
// validateHashStrings validates hash string format(s) and outputs results.
// Returns appropriate exit code.
func validateHashStrings(cfg *config.Config, colorHandler *color.ColorHandler) int
```

**Output format**:
```
âœ… Valid SHA-256 hash format (64 hex characters)
```

For ambiguous lengths:
```
âœ… Valid hash format (128 hex characters)
   Could be: SHA-512, BLAKE2b-512
   Specify algorithm with --algo to verify a file
```

For invalid:
```
âŒ Invalid hash format
   Expected 64 hex characters for SHA-256, got 32
   This looks like MD5. Use: hashi --algo md5 [hash]
```

#### Task 4.2: File + Hash Comparison Mode
**File**: `cmd/hashi/main.go`

**Add logic** (after hash validation check):
```go
// Mode 2: Single file + single hash comparison
// User ran: hashi file.txt [hash_string]
if len(cfg.Files) == 1 && len(cfg.Hashes) == 1 {
    exitCode := compareFileToHash(cfg, colorHandler, errHandler)
    os.Exit(exitCode)
}
```

**New function to implement**:
```go
// compareFileToHash computes a file's hash and compares to provided hash.
// Outputs PASS/FAIL result based on cfg.OutputFormat.
// Returns appropriate exit code.
func compareFileToHash(cfg *config.Config, colorHandler *color.ColorHandler, errHandler *errors.ErrorHandler) int
```

**Output formats**:

Default (human-readable):
```
[SHA-256] Verifying file.txt...
âœ… PASS: Hash matches provided string.
```

```
[SHA-256] Verifying file.txt...
ðŸ”´ FAIL: Hash mismatch!
   Expected: a1b2c3d4e5f6...
   Computed: f0e1d2c3b4a5...
```

With `--bool` flag:
```
true
```
or
```
false
```

With `--quiet` flag:
```
(no output, only exit code)
```

**Exit codes**:
- 0: Match (PASS)
- 1: No match (FAIL)
- 4: File not found
- 5: Permission denied
- 2: Other processing error

#### Task 4.3: Add Boolean Output Flag
**File**: `internal/config/config.go`

**Add to Config struct** (around line 59):
```go
BoolOutput bool // Output only "true"/"false" for scripting
```

**Add to ParseArgs** (around line 580):
```go
fs.BoolVarP(&cfg.BoolOutput, "bool", "b", false, "Output only true/false for scripting")
```

**Add validation** (in ValidateConfig, around line 380):
```go
// Validate mutually exclusive output flags
if cfg.BoolOutput && cfg.Quiet {
    return fmt.Errorf("--bool and --quiet are mutually exclusive")
}
if cfg.BoolOutput && cfg.OutputFormat != "default" {
    return fmt.Errorf("--bool cannot be used with --format")
}
```

**Update help text** (in HelpText function, around line 680):
```go
OUTPUT FORMATS
  -f, --format string       Output format: default, verbose, json, plain
      --json                Shorthand for --format=json
      --plain               Shorthand for --format=plain
  -b, --bool                Output only true/false (for scripting)
  -o, --output string       Write output to file
      --append              Append to output file
      --force               Overwrite without prompting
```

---

### PHASE 5: Testing

#### Task 5.1: Test Hash Detection
**File**: `internal/hash/hash_test.go`

**Add test**:
```go
func TestDetectHashAlgorithm(t *testing.T) {
    tests := []struct {
        name     string
        hashStr  string
        expected []string
    }{
        {"MD5", "d41d8cd98f00b204e9800998ecf8427e", []string{"md5"}},
        {"SHA-1", "da39a3ee5e6b4b0d3255bfef95601890afd80709", []string{"sha1"}},
        {"SHA-256", "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855", []string{"sha256"}},
        {"SHA-512/BLAKE2b ambiguous", "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e", []string{"sha512", "blake2b"}},
        {"CRC32", "12345678", []string{"crc32"}},
        {"Invalid hex", "gggggggg", []string{}},
        {"Wrong length", "abc", []string{}},
        {"Empty", "", []string{}},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := DetectHashAlgorithm(tt.hashStr)
            // Compare slices...
        })
    }
}
```

#### Task 5.2: Test Argument Classification
**File**: `internal/config/config_test.go`

**Add test**:
```go
func TestClassifyArguments(t *testing.T) {
    // Create temporary test files
    tmpFile := createTempFile(t, "test.txt", "content")
    defer os.Remove(tmpFile)
    
    tests := []struct {
        name          string
        args          []string
        algorithm     string
        expectFiles   []string
        expectHashes  []string
        expectError   bool
        errorContains string
    }{
        {
            name:         "Only files",
            args:         []string{tmpFile},
            algorithm:    "sha256",
            expectFiles:  []string{tmpFile},
            expectHashes: []string{},
            expectError:  false,
        },
        {
            name:         "File and matching hash",
            args:         []string{tmpFile, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},
            algorithm:    "sha256",
            expectFiles:  []string{tmpFile},
            expectHashes: []string{"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},
            expectError:  false,
        },
        {
            name:          "File and non-matching hash (MD5 when expecting SHA-256)",
            args:          []string{tmpFile, "d41d8cd98f00b204e9800998ecf8427e"},
            algorithm:     "sha256",
            expectError:   true,
            errorContains: "This looks like MD5",
        },
        {
            name:          "Ambiguous hash length",
            args:          []string{tmpFile, "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"},
            algorithm:     "sha256",
            expectError:   true,
            errorContains: "Could be: sha512, blake2b",
        },
        {
            name:         "Non-existent file (not a hash)",
            args:         []string{"nonexistent.txt"},
            algorithm:    "sha256",
            expectFiles:  []string{"nonexistent.txt"},
            expectHashes: []string{},
            expectError:  false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            files, hashes, err := ClassifyArguments(tt.args, tt.algorithm)
            // Assertions...
        })
    }
}
```

#### Task 5.3: Integration Tests
**File**: New file `cmd/hashi/main_test.go` or integration test suite

**Test scenarios**:
1. Hash validation: `hashi [valid_sha256_hash]` â†’ exit 0, shows "Valid"
2. Hash validation: `hashi [invalid_hash]` â†’ exit 3, shows error
3. File + hash match: `hashi file.txt [matching_hash]` â†’ exit 0, shows PASS
4. File + hash mismatch: `hashi file.txt [wrong_hash]` â†’ exit 1, shows FAIL
5. Bool output: `hashi --bool file.txt [hash]` â†’ outputs "true" or "false"
6. Quiet output: `hashi --quiet file.txt [hash]` â†’ no output, only exit code
7. Wrong algorithm: `hashi file.txt [md5_hash]` â†’ exit 3, suggests --algo md5

---

### PHASE 6: Documentation

#### Task 6.1: Update Help Text
**File**: `internal/config/config.go` - `HelpText()` function

**Add to EXAMPLES section**:
```
  hashi file.txt a1b2c3d4...        Verify file matches hash
  hashi a1b2c3d4...                 Validate hash string format
  hashi --bool file.txt hash        Output true/false for scripting
```

**Add new section** (after STDIN SUPPORT):
```
HASH VERIFICATION
  hashi file.txt [hash]     Compare file hash to provided hash string
                            Hash must match current algorithm (default: SHA-256)
                            Use --algo to specify different algorithm
  
  hashi [hash]              Validate hash string format
                            Reports which algorithm(s) it could be

EXAMPLES
  hashi file.txt e3b0c442...                    # Verify SHA-256 hash
  hashi --algo md5 file.txt d41d8cd9...         # Verify MD5 hash
  hashi e3b0c442...                             # Validate hash format
  hashi --bool file.txt hash                    # Script-friendly output
```

#### Task 6.2: Update README.md
**File**: `README.md`

**Update Quick Start section** (around line 40):
```bash
# Compare a file against a hash string
hashi file.txt e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

# Validate a hash string format
hashi e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

# Script-friendly boolean output
hashi --bool file.txt [hash] && echo "Verified!" || echo "Failed!"
```

**Add new section** (after "Quick Start", before "Project Structure"):
```markdown
## Configuration

### Setting Default Algorithm

You can set a default hash algorithm so you don't need to specify `--algo` every time:

**Option 1: Config File (Recommended)**
```bash
# Create user config directory
mkdir -p ~/.config/hashi

# Create config file
cat > ~/.config/hashi/config.json << EOF
{
  "algorithm": "sha512",
  "recursive": true,
  "hidden": false
}
EOF
```

**Option 2: Environment Variable**
```bash
# Add to ~/.bashrc or ~/.zshrc
export HASHI_ALGORITHM=sha512
export HASHI_RECURSIVE=true
```

**Option 3: Project-Specific Config**
```bash
# Create .hashi.json in your project directory
echo '{"algorithm": "sha512"}' > .hashi.json
```

### Config File Locations

hashi automatically loads config from (in order of precedence):
1. `./.hashi.json` - Project-specific settings
2. `~/.config/hashi/config.json` - User settings (XDG standard)
3. `~/.hashi/config.json` - Alternative user settings

### Configuration Precedence

Settings are applied in this order (highest priority first):
1. Command-line flags (`--algo sha512`)
2. Environment variables (`HASHI_ALGORITHM=sha512`)
3. Config file (auto-loaded or `--config` specified)
4. Built-in defaults (SHA-256, non-recursive, etc.)

### Available Settings

All command-line flags can be set in config files or environment variables:

| Config File | Environment Variable | Flag | Default |
|-------------|---------------------|------|---------|
| `algorithm` | `HASHI_ALGORITHM` | `--algo` | `sha256` |
| `recursive` | `HASHI_RECURSIVE` | `--recursive` | `false` |
| `hidden` | `HASHI_HIDDEN` | `--hidden` | `false` |
| `output_format` | `HASHI_OUTPUT_FORMAT` | `--format` | `default` |
| `verbose` | `HASHI_VERBOSE` | `--verbose` | `false` |
| `quiet` | `HASHI_QUIET` | `--quiet` | `false` |
```

#### Task 6.3: Update Examples Documentation
**File**: `hashi_examples.md`

**Review sections** 1.3, 1.4, 1.5 (already documented):
- Ensure implementation matches documented behavior
- Update output examples if needed
- Add `--bool` flag examples

**Add new section** (after section 6):
```markdown
## 7. Configuration Examples

### 7.1 User-Wide Default Algorithm
**Scenario:** You work with SHA-512 hashes daily and want it as your default.
**Setup:**
```bash
mkdir -p ~/.config/hashi
echo '{"algorithm": "sha512"}' > ~/.config/hashi/config.json
```
**Usage:**
```bash
# Now uses SHA-512 by default
hashi file.txt

# Override when needed
hashi --algo sha256 file.txt
```

### 7.2 Project-Specific Settings
**Scenario:** Your project uses MD5 for legacy compatibility.
**Setup:**
```bash
# In your project directory
cat > .hashi.json << EOF
{
  "algorithm": "md5",
  "recursive": true,
  "exclude": ["node_modules/**", "*.log"]
}
EOF
```
**Usage:**
```bash
# Automatically uses project settings
hashi
```

### 7.3 Environment Variables for CI/CD
**Scenario:** Your CI pipeline needs consistent settings across jobs.
**Setup (in .gitlab-ci.yml or similar):**
```yaml
variables:
  HASHI_ALGORITHM: sha256
  HASHI_QUIET: true
  HASHI_OUTPUT_FORMAT: json
```
**Usage:**
```bash
# In CI script - uses env vars automatically
hashi dist/*.tar.gz > checksums.json
```
```

---

## Edge Cases & Design Decisions

### Decision 1: Multiple Files + Multiple Hashes
**Scenario**: `hashi file1.txt file2.txt hash1 hash2`

**Options**:
- A) Compare each file against all hashes (show which match)
- B) Error: "Multiple files with multiple hashes not supported"
- C) Treat as normal batch processing (ignore hashes, just compute and group)

**Recommendation**: Option B for now (simplest, clearest behavior)

**Implementation**: Add check in main.go:
```go
if len(cfg.Files) > 1 && len(cfg.Hashes) > 0 {
    return error("Cannot compare multiple files with hash strings. Use one file at a time.")
}
```

### Decision 2: Stdin with Hashes
**Scenario**: `echo "file.txt" | hashi - hash123`

**Recommendation**: Not supported initially. Error if both stdin marker and hashes present.

**Implementation**: Add check in main.go:
```go
if cfg.HasStdinMarker() && len(cfg.Hashes) > 0 {
    return error("Cannot use stdin input with hash comparison")
}
```

### Decision 3: File Named Like a Hash
**Scenario**: User has a file literally named `e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`

**Solution**: Already handled - filesystem check happens FIRST in ClassifyArguments.

### Decision 4: Case Sensitivity
**Scenario**: Hash strings can be uppercase, lowercase, or mixed

**Solution**: Normalize to lowercase before comparison:
```go
hashStr = strings.ToLower(hashStr)
```

Apply in:
- `DetectHashAlgorithm()` - before validation
- `compareFileToHash()` - before comparison

---

## Implementation Order

1. **Phase 1** (Core Detection): Tasks 1.1 â†’ 1.2 â†’ 1.3
2. **Phase 2** (Configuration): Tasks 2.1 â†’ 2.2 â†’ 2.3 â†’ 2.4
3. **Phase 3** (Config Testing): Tasks 3.1 â†’ 3.2
4. **Phase 4** (New Features): Tasks 4.1 â†’ 4.2 â†’ 4.3
5. **Phase 5** (Feature Testing): Tasks 5.1 â†’ 5.2 â†’ 5.3
6. **Phase 6** (Documentation): Tasks 6.1 â†’ 6.2 â†’ 6.3

**Estimated effort**: 6-8 hours for full implementation and testing

---

## Success Criteria

- [ ] Config files auto-load from standard locations (./.hashi.json, ~/.config/hashi/config.json, ~/.hashi/config.json)
- [ ] Environment variables (HASHI_ALGORITHM, etc.) work correctly
- [ ] Configuration precedence works: flags > env vars > config file > defaults
- [ ] `hashi [hash]` validates hash format and reports algorithm(s)
- [ ] `hashi file.txt [hash]` compares and outputs PASS/FAIL
- [ ] `hashi file.txt [wrong_algo_hash]` gives helpful error with --algo suggestion
- [ ] `hashi --bool file.txt [hash]` outputs "true" or "false"
- [ ] `hashi --quiet file.txt [hash]` uses only exit codes
- [ ] All tests pass (config loading, hash detection, argument classification, integration)
- [ ] Documentation updated and accurate (help text, README, examples)
- [ ] Edge cases handled gracefully

---

## Notes

- This implements the original "hash machine" concept from scratchpad3.txt
- Option C (Hybrid) balances convenience with explicitness
- Follows CLI guidelines: helpful errors, no surprises, composable
- Maintains backward compatibility (existing functionality unchanged)
- **Config auto-loading** follows industry standards (git, npm, docker patterns)
- **XDG Base Directory** specification compliance for Linux/Unix systems
- **Project-specific configs** enable per-project algorithm preferences
- **No `hashi config` subcommand** initially - users can edit JSON directly (can add later if requested)
